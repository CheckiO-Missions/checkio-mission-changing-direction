<body data-author="freeman_lex">
<div class="question-answer">
    <div class="question">
        <p>Nie mam pojcia, jak zacz rozwizywa t misj.</p>
    </div>
    <div class="answer">
        <p>
            musi Pan znale藕 i zaznaczy na licie wszystkie kawaki z kierunkiem, kt贸ry si nie zmienia. Poniewa偶 kierunek zmienia si midzy dwoma ssiednimi fragmentami, liczba takich zmian to liczba fragment贸w minus jeden.
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>Ok, od czego powinienem zacz?</p>
    </div>
    <div class="answer">
        <p>
            Pierwszym krokiem jest zadeklarowanie zmiennej <b class="code">dirs</b> z pocztkow wartoci pustej listy. Tam prosz przechowywa swoje znaczniki dla chunk贸w o pozostaym kierunku. 
        </p>
        <pre class="brush: python">
dirs = []
        </pre>
        <p>
            Teraz, aby znale藕 kierunek (kolejno) midzy dwoma elementami, nale偶y je por贸wna i powt贸rzy dla ka偶dej ssiedniej pary: 0-ty z 1-szym, 1-szy z 2-im itd. W takim przypadku wbudowana funkcja <a target="_blank" href="https://www.w3schools.com/python/ref_func_zip.asp">zip()</a> jest bardzo przydatna! Pozwala ona na iteracj po dw贸ch lub wicej sekwencjach i pobranie element贸w o tym samym indeksie do koca najkr贸tszej sekwencji. 
        </p>
        <pre class="brush: python">
dirs = []
for i, j in zip(...):
    ...
        </pre>
        <p>
            Gdzie <b class="code">i</b> to ka偶dy element pierwszej sekwencji, <b class="code">j</b> element o odpowiednim indeksie z drugiej sekwencji (poniewa偶 por贸wnuj Pastwo dwie liczby, potrzebne s dwie sekwencje).
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>
            Ok, elementy jakich sekwencji powinienem por贸wna?
        </p>
    </div>
    <div class="answer">
        <p>
            Prosz si zastanowi. Jak wspomniaem powy偶ej, musi Pan por贸wna 0-t z 1-st, 1-st z 2-st, 2-st z 3-st... Tak wic pierwsza sekwencja zaczyna si od pocztku pocztkowej listy, ale druga sekwencja zaczyna si od 1-stego elementu pocztkowej listy. 
        </p>
        <p>
            Aby otrzyma drug sekwencj do por贸wnania jako pocztkow list od pierwszego elementu, prosz u偶y <a target="_blank" href="https://railsware.com/blog/python-for-machine-learning-indexing-and-slicing-for-lists-tuples-strings-and-other-sequential-types/">slicing</a>.
        </p>
        <pre class="brush: python">
dirs = []
for i, j in zip(elements, elements[1:]):
    ...
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>
            Jak nale偶y por贸wna elementy?
        </p>
    </div>
    <div class="answer">
        <p>
            Oto maa uwaga, o kt贸rej powinni Pastwo pamita. W tym rozwizaniu bdziemy u偶ywa "+" dla rosncej kolejnoci chunk贸w i "-" dla malejcej. W rzeczywistoci mo偶na u偶y dowolnych dw贸ch r贸偶nych symboli.
        </p>
        <p>
            Powiedzmy, 偶e <b class="code">j> i</b>, co oznacza, 偶e na przykad element 1 jest wikszy ni偶 element 0. Okrela to rosnc kolejno element贸w ("+"). Co nale偶y z tym zrobi? Jeli w <b class="code">dirs</b> nie ma zapisanego kierunku (pusty: por贸wnywana jest pierwsza para element贸w lub te same elementy z pocztku pocztkowej listy i nie mo偶na okreli kolejnoci) lub ostatni zapisany kierunek element贸w nie jest rosncy ("-"), nale偶y doda nowy bie偶cy kierunek do <b class="code">dirs</b>, poniewa偶 kierunki wanie si zmieniy (lub ustawiy). 
        </p>
        <pre class="brush: python">
dirs = []
for i, j in zip(elements, elements[1:]):
    if j> i and (not dirs or dirs[-1] == '-'):
        dirs.append('+')
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>
            Co powinienem zrobi dalej?
        </p>
    </div>
    <div class="answer">
        <p>
            Prosz uzupeni instrukcj warunkow <b class="code">if</b> czci <b class="code">elif</b> i zrobi to samo dla kierunku malejcego - <b class="code">j < i</b>.
        </p>
        <pre class="brush: python">
dirs = []
for i, j in zip(elements, elements[1:]):
    if j> i and (not dirs or dirs[-1] == '-'):
        dirs.append('+')
    elif j < i and (not dirs or dirs[-1] == '+'):
        dirs.append('-')
        </pre>
        <p>
            Oba por贸wnania s cise, poniewa偶 jeli ssiednie elementy s r贸wne, kolejno pozostaje taka sama (nie ma potrzeby dodawania kilku takich samych znak贸w jeden po drugim) lub nie mo偶na jej jeszcze okreli (te same elementy od pocztku pocztkowej listy - nie ma potrzeby dodawania 偶adnego znaku).
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>
            Co dokadnie powinna zwraca funkcja?
        </p>
    </div>
    <div class="answer">
        <p>
            Jeli <b class="code">dirs</b> pozostaje pusty (wszystkie elementy s r贸wne) lub ma jeden element (caa pocztkowa sekwencja ma tylko jeden kierunek (asc lub desc)), Pana funkcja powinna zwr贸ci <b class="code">0</b> - brak zmian kierunku. W przeciwnym razie funkcja powinna zwr贸ci liczb zmian, kt贸ra jest dugoci <b class="code">dirs</b> minus 1, jako liczb ssiednich par wewntrz <b class="code">dirs</b>. 
        </p>
        <p>
            Oto kr贸tki spos贸b zapisu wszystkich tych wariant贸w.
        </p>
        <pre class="brush: python">
return len(dirs) - bool(dirs)
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>Jak wic powinno wyglda moje ostateczne rozwizanie?</p>
    </div>
    <div class="answer">
        <p>
            Prosz tylko poczy kod i zawin go w wyra偶enie funkcyjne.
        </p>
        <p>Oto cae rozwizanie:</p>
        <div class="spoiler">
        <pre class="brush: python">
def changing_direction(elements: list[int]) -> int:

    dirs = []
    for i, j in zip(elements, elements[1:]):
        if j> i and (not dirs or dirs[-1] == '-'):
            dirs.append('+')
        elif j < i and (not dirs or dirs[-1] == '+'):
            dirs.append('-')
    
    return len(dirs) - bool(dirs)
        </pre>
        </div>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>Prosz pokaza mi wicej rozwiza!<br />
        bo chc by prawdziw  Python Ninnjaa!</p>
    </div>
    <div class="answer">
        <p>Jasne, prosz apa!</p>
        <p>
            Za ka偶dym razem, gdy zmienia si kierunek, iloczyn bie偶cego i poprzedniego kierunku staje si mniejszy ni偶 0: "+"*"-"=="-". To rozwizanie zlicza takie iloczyny. 
        </p>
        <div class="spoiler">
        <pre class="brush: python">
def changing_direction(elements: list[int]) -> int:

    dir = count = 0
    for a, b in zip(elements, elements[1:]):
        dir2 = a - b
        if dir2:
            if dir2 * dir < 0:
                count += 1
            dir = dir2

    return count
        </pre>
        </div>
        <p>
            Rozwizanie to polega na wykonaniu nastpujcych czynnoci: utworzeniu listy zawierajcej wszystkie r贸偶nice midzy ssiednimi nier贸wnymi elementami, utworzeniu generatora iloczyn贸w midzy ssiednimi r贸偶nicami z poprzedniej listy, zliczeniu liczby ujemnych iloczyn贸w (sygna zmiany kierunku). 
        </p>
        <div class="spoiler">
        <pre class="brush: python">
def changing_direction(e: list[int]) -> int:

    d = [x - y for x, y in zip(e, e[1:]) if x!= y]

    return sum(x * y < 0 for x, y in zip(d, d[1:]))
        
        </pre>
        </div>
        <p>Prosz klikn <b>Best Solutions</b> w menu misji i zobaczy wiele innych ciekawych rozwiza!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        <p>Dziki! Teraz wiem i rozumiem wicej! Wszystko dziaa jak nale偶y!</p>
    </div>
    <div class="answer">
        mio mi to sysze!
    </div>
</div>
</body>
